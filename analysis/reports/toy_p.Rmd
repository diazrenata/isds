---
title: "Exploring analysis of rank P plots"
output: github_document
---

```{r setup}
library(drake)
library(isds)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)

## Set up the cache and config
db <- DBI::dbConnect(RSQLite::SQLite(), here::here("drake", "drake-cache.sqlite"))
cache <- storr::storr_dbi("datatable", "keystable", db)
```

Get a sim.

```{r get a sim}
loadd(ids_dat1, cache = cache)

empirical <- ids_dat1[[1]]
sim <- ids_dat1[[2]]

loadd(sims_dat1, cache = cache)
empirical_dat <- sims_dat1[[1]]
sim_dat <- sims_dat1[[2]]
rm(sims_dat1)
rm(ids_dat1)
```

```{r plot}
e <- plot_integrated_density(empirical$integrated_density, plot_title = "empirical") +
  geom_vline(xintercept = c(log(min(empirical_dat$community$wgt)), log(max(empirical_dat$community$wgt))))
s <- plot_integrated_density(sim$integrated_density, plot_title = "sim")+
  geom_vline(xintercept = c(log(min(sim_dat$community$wgt)), log(max(sim_dat$community$wgt))))
gridExtra::grid.arrange(grobs = list(e, s), nrow = 1)
```

Truncate to min and max body size? Plus a buffer of log units?

```{r truncate ids}
truncate_id <- function(id_list, dat) {
  id_list$integrated_density <- id_list$integrated_density %>%
  dplyr::filter(dplyr::between(start, log(min(dat$community$wgt)) - .1,
                             log(max(dat$community$wgt)) + .1))
  return(id_list)
}


sim_t <- truncate_id(sim, sim_dat)
empirical_t <- truncate_id(empirical, empirical_dat)

e_t <- plot_integrated_density(empirical_t$integrated_density, plot_title = "empirical truncated") +
  geom_vline(xintercept = c(log(min(empirical_dat$community$wgt)), log(max(empirical_dat$community$wgt))))
s_t <- plot_integrated_density(sim_t$integrated_density, plot_title = "sim truncated")+
  geom_vline(xintercept = c(log(min(sim_dat$community$wgt)), log(max(sim_dat$community$wgt))))
gridExtra::grid.arrange(grobs = list(e_t, s_t), nrow = 1)

```

Try fitting inverse parabolas?

```{r inverse parabolas}
y <- sim_t$integrated_density$by_max
x <- sim_t$integrated_density$start
fit2 <- lm(y~poly(x,2,raw=TRUE))
normal_fit <- dnorm(x, mean = mean(sim_t$integrated_density$by_max), sd =
                      sd(sim_t$integrated_density$by_max))

fitplot <- plot_integrated_density(sim_t$integrated_density) +
  geom_point(aes(x = x, y = predict(fit2, as.data.frame(x))), color = "green") +
  geom_point(aes(x= x, y = normal_fit), color = "blue")
fitplot
```
