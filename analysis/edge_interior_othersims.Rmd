---
title: "Measuring overlap in SBSDs"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(isds)
library(dplyr)
library(ggplot2)
```

SBSD = species body size distribution. The frequency/probability density of body sizes across all individuals of a species.

## Rationale & background of using overlap

The ISD (the size distribution across all individuals of all species) is...slippery and often subject to interpretation.

Both Holling and ESS would predict polarized/bimodal distribution of overlap among all pairings of species. Species should either be quite similar or quite different, so high or low, but not intermediate, overlap.

I've imported the SBSD overlap metric from [Read et al 2018](https://onlinelibrary.wiley.com/doi/full/10.1111/ecog.03641): 

1. For all pairs of species in a community, construct the KDEs across the entire body size range and standardize so each KDE integrates to 1. 
2. Integrate the minimum of the two KDEs at each evaluation point. 

In principle this varies from 0 to 1 for each pair of species.

## Foreshadowing artefacts from rare species

1. Pointy KDEs
2. Higher uncertainty wrt the true SBSD mean, sd, and indeed entire distribution.
3. We may inherently want to downweight rare species, but *this is separate from* the above.

## Demo with simple cases

Let's leave rare species aside for the moment, and focus on how we expect the overlap distributions to come out under a few toy scenarios: 

1. All species are essentially the same; complete overlap
2. Two clusters of species. Within clusters, species are essentially the same. The clusters do not overlap.
3. All species are distinct and do not overlap.
4. All species are different but overlap significantly.

For now, we will give all species an equal, reasonably large, number of individuals (50). This is wildly unrealistic for real communities.

We will assume all species' SBSDs are normal distributions, and that the standard deviation scales with the mean according to some coefficient. `.15` seems like a plausible coefficient to me. 

```{r draw communities, include = F}

scenarios <- list(
  complete_overlap = c(50, 50, 50, 50, 50, 50),
  two_clusters = c(20, 20, 20, 90, 90, 90),
  all_distinct = c(15, 25, 40, 80, 120, 250),
  partial_overlap = c(30, 45, 60, 75, 90, 105)
)
abunds <- c(50, 50, 50, 50, 50, 50)

set.seed(2)
scenario_communities <- lapply(scenarios, FUN = sample_community, abunds = abunds)

scenario_plots <- lapply(scenario_communities, FUN = plot_pipeline)
```

```{r show plots, echo = F, fig.dim=c(6,2)}
for(i in 1:length(scenario_plots)) {
  
  suppressWarnings(gridExtra::grid.arrange(grobs = scenario_plots[[i]], nrow = 1, top = grid::textGrob(names(scenarios)[i],gp=grid::gpar(fontsize=12))))
}

```

In these scenarios, the overlap metric behaves as expected. We have high overlap values when we have species we think should overlap fully, near 0 when there are either clumps that do not overlap or when there's no overlap between any species, and a spectrum of intermediate values when all the species overlap partially.

We would like a way to summarize the rightmost plots in a single metric. Let's try the proportion of values in the upper 30 and lower 20%.

```{r edge interior ratio}

overlap_dfs <- lapply(scenario_communities, FUN = community_overlap)

edge_proportion(overlap_dfs[[4]])
```
## Adding a logseries SAD

```{r sample with SAD, include = F}

ls_abunds <- unlist(scads::sample_METE(s = 6, n = 300, nsamples = 1))

ls_abunds[ which(ls_abunds == 1)] <- 2

ls_abunds <- sample(ls_abunds, size = 6, replace = F)

ls_communities <- lapply(scenarios, FUN = sample_community, abunds = ls_abunds)

ls_plots <- lapply(ls_communities, FUN = plot_pipeline)

```

Let's add this SAD, drawn from the METE logseries. We'll assign abundance to species at random. We can't construct a kde for a species with one individual, so we're coercing any species that gets 1 to have 2 individuals.


```{r plot sad, fig.dim = c(2,2), echo = F}

sad_plot <- ggplot(data = data.frame(abund = sort(ls_abunds), rank = 1:6), aes(x = rank, y = abund)) +
  geom_line() +
  theme_bw()

sad_plot

ls_abunds
```

```{r plot ls outcomes, fig.dim = c(6, 2), echo = F}
for(i in 1:length(ls_plots)) {
  
  suppressWarnings(gridExtra::grid.arrange(grobs = ls_plots[[i]], nrow = 1, top = grid::textGrob(paste0(names(scenarios)[i], " + logseries SAD"),gp=grid::gpar(fontsize=12))))
}
```

Just adding the SAD - and drawing all our samples from the *same distributions as above* - turns up unexpected overlap results. We get unexpectedly low values for the complete overlap scenario, because we are constructing kdes for low abundance species based on very few samples. Those samples may be off the "true" mean, and the resulting kde is much pointier than one constructed off of more samples. I think the complete_overlap purple species illustrates being off the mean, and the complete_overlap purple species illustrates the pointy kde. We also got some overlaps pushed downards in the partial_overlap scenario, again because of artifiically pointy kdes. 


## Upsample with error propagation

```{r upsample with error, include = F}
ls_abunds_up <- rep(200, times = 6)

ls_new_means <- lapply(ls_communities, FUN = function(community_df) 
  return((community_df %>% group_by(species) %>% summarize(meanwgt = mean(wgt)) %>% ungroup())$meanwgt))

ls_up_error_communities <- lapply(ls_new_means, FUN = sample_community, abunds = ls_abunds_up)

ls_up_error_plots <- lapply(ls_up_error_communities, FUN = plot_pipeline)

```

Here's how well we recovered the true means: (actually pretty well)

```{r show mean recovery, echo = F, fig.dim = c(5,4)}

mean_recovery <- left_join(
  bind_rows(ls_new_means) %>%
    mutate(species = row_number()) %>%
    tidyr::gather(-species, key = "source", value = "recovered_mean"),
  bind_rows(scenarios) %>%
    mutate(species = row_number()) %>%
    tidyr::gather(-species, key = "source", value = "original_mean"),
  by = c("source", "species")
) %>%
  left_join(data.frame(species = 1:6, abund = ls_abunds), by = "species")

mean_recovery_plot <- ggplot(data = mean_recovery, aes(x = original_mean, y = recovered_mean, color = log(abund))) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1) +
  facet_wrap(vars(source), scales = "free") +
  theme_bw() +
  scale_color_viridis_c(option = "magma", direction = -1,  end = .9)
mean_recovery_plot
```


And here's the outcomes:

```{r show error prop outcomes, echo = F, fig.dim = c(6,2)}
for(i in 1:length(ls_up_error_plots)) {
  
  suppressWarnings(gridExtra::grid.arrange(grobs = ls_up_error_plots[[i]], nrow = 1, top = grid::textGrob(paste0(names(scenarios)[i], " + logseries SAD + upsampled N based on logseries means"),gp=grid::gpar(fontsize=12))))
}
```

## Many samples

Now let's take the same pipeline as above, run it many times, and report the edge proportion.

For now we'll retain all the intermediate samples. This will be unwieldly eventually, but for now I suspect I'll want to look closely at some of them.

```{r many samples}

replicate_samples <- function(means_vect, abunds_vect, times = 100) {
  return(replicate(sample_community(means = means_vect, abunds = abunds_vect), n = times, simplify = F))
}

resample_community <- function(community_df) {
  summary_df <- community_df %>%
    group_by(species) %>%
    summarize(meanwgt = mean(wgt),
              abund = dplyr::n()) %>%
    ungroup()
  
  newabund <- ceiling(summary_df$abund * 50 / min(summary_df$abund))
  
  new_community <- sample_community(means = summary_df$meanwgt, abunds = newabund)
  return(new_community)
}

set.seed(5)

even_sims <- lapply(scenarios, FUN = replicate_samples, abunds_vect = abunds)

ls_sims <- lapply(scenarios, FUN = replicate_samples, abunds_vect = ls_abunds)

ls_upsampled_sims <- lapply(ls_sims, FUN = function(sims_list) return(lapply(sims_list, FUN = resample_community)))

extract_edge_prop <- function(sims_list) {
  return(data.frame(sim = 1:length(sims_list), edge_prop = vapply(sims_list, FUN = function(community_df) return(edge_proportion(community_overlap(community_df))), FUN.VALUE = 1)))
}

even_overlaps <- lapply(even_sims, FUN = extract_edge_prop)
ls_overlaps <- lapply(ls_sims, FUN = extract_edge_prop)
ls_up_overlaps <- lapply(ls_upsampled_sims, FUN = extract_edge_prop)

even_overlaps <- bind_rows(even_overlaps, .id = "source")
ls_overlaps <- bind_rows(ls_overlaps, .id = "source")
ls_up_overlaps <- bind_rows(ls_up_overlaps, .id = "source")

all_overlaps <- bind_rows(list(even = even_overlaps, ls = ls_overlaps, ls_up = ls_up_overlaps), .id = "sampling")

head(all_overlaps)
# 
# extract_edge_prop_w <- function(sims_list, wcol = "prod_n") {
#   return(data.frame(sim = 1:length(sims_list), edge_prop = vapply(sims_list, FUN = function(community_df) return(edge_proportion(community_overlap(community_df), weight_col = wcol)), FUN.VALUE = 1)))
# }
# 
# even_overlaps_w <- lapply(even_sims, FUN = extract_edge_prop_w)
# ls_overlaps_w <- lapply(ls_sims, FUN = extract_edge_prop_w)
# ls_up_overlaps_w <- lapply(ls_upsampled_sims, FUN = extract_edge_prop_w)
# 
# even_overlaps_w <- bind_rows(even_overlaps_w, .id = "source")
# ls_overlaps_w <- bind_rows(ls_overlaps_w, .id = "source")
# ls_up_overlaps_w <- bind_rows(ls_up_overlaps_w, .id = "source")
# 
# all_overlaps_w <- bind_rows(list(even = even_overlaps_w, ls = ls_overlaps_w, ls_up = ls_up_overlaps_w), .id = "sampling")
# 
# head(all_overlaps_w)
```
```{r show all overlaps}

overlaps_plot <- ggplot(data = all_overlaps, aes(x = edge_prop, fill = source)) +
  geom_histogram(binwidth = .1, boundary = 0) +
  xlim(-.2, 1.2) +
  theme_bw() +
  facet_wrap(vars(sampling,source), scales = "free_y", strip.position = "top") + 
  scale_fill_viridis_d(option = "plasma", end = .8)
overlaps_plot
# 
# overlaps_w_plot <- ggplot(data = all_overlaps_w, aes(x = edge_prop, fill = source)) +
#   geom_histogram(binwidth = .1, boundary = 0) +
#   xlim(-.2, 1.2) +
#   theme_bw() +
#   facet_wrap(vars(sampling,source), scales = "free_y", strip.position = "top") + 
#   scale_fill_viridis_d(option = "plasma", end = .8)
# overlaps_w_plot
```
